Contract Class For Content Provider :
we created nested class for accessing the tables
for mentioning the columns we can write the constans in each table class separately but sometimes columns
maybe be repeated in different classes so to remove this redundancy we make an interface for column constants .
these interfaces group related constants together and also this process simplifies the organisation and
maintainence of the constants.
these interfaces are nested within our contract classes
But are not intented to be used directlt outside the provider
So we make them as protected
Now if the table wants to associate the column constants they need to implement particular interfaces .

public static final class Courses implements CoursesColumns >>>
if we want to access course_title column >>> Courses.COLUMN_COURSE_TITLE

Using UriMatcher for proper Uri handling .

Content providers can abstract the storage details and present whatever tables they would like to present
even if they are not exactly the way the data is stored .
so main activity can use the content provider for a table having note info along with course title rather than
course id without even joining the table .. the content provider contract will have another uri for that .
So we will still be obtaining the result by joining the tables but that info is encapsulated within the content provider .
The main activity only accesses the new URI and gets the list of notes along with the corresponding course title .

Interacting With Content Provider :
for operation like accessing the content we used cursor loader which itself took care of carrying out the query in CP
but in case of insertion deletion and updation queries we will use Content Resolver
the cursorLoader itself uses Content resolver to access the Content provider but we can also use the content Resolver oursef
So we need to first get reference to the content Resolver and then perform operations

Row Uris are used for performing opns on specific rows .
for a rowUri we append the table uri with "/#"
in case of rowUri we handle the selection criteria on our own

to make other apps able to use our content provider class easily we must export our class to an nadroid library or a jar file .
>>>> https://developer.android.com/studio/projects/android-library.html

Mime type is a way to describe data .. our data is not a common mime type like an image or an xml
it is a cursor based data and actual structure of it is defined by our application
so we need to construct our own mime type .

Notifications >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
we will use android helper class for this
Files > New > UI COMponent > Notification
notify method is responsible for crearing and displaying the notification .

Pending Intent >> wraps up the intent and action that needs to be performed with that intent .
if using additional actions the , the notification won't cancel on it's own . it needs to be cancelled explicitly .

Leveraging the android Platform >>>>>>>>>>>>>>>>>>>>>>>>>>>.
Thrading Model >>>>>>>>>>>>>>>>
Common opns we need to avoid performing on the main thread are reading from disc storage and writing to disc storage.
Strict mode class can detect undesirable opns and enforce a penalty when detected .
we create thread policy . > things we wish to detect .. what penalty we want .
AsyncTask accepts three type parameters  :::: <Type1(input parameters for doinBackground), Type2(void for now),
                                                Type3(return type of doInBackground or parameter type of onPostExecute)

Handlers ... to make a delay

Services >>> allows us to perform non Ui work within our application .it tells android that the work we are doing
in a service is meaningful even if we are presenting a user interface .
services basically help us to perform long running background work .. so that it is still running even if the user
switches to another app .we submit intent to a service .